"""Custom client handling, including {{ cookiecutter.source_name }}Stream base class."""

import requests
from pathlib import Path
from typing import Any, Dict, Optional, Union, List, Iterable

from singer_sdk.streams import Stream


class {{ cookiecutter.source_name }}Stream(Stream):
    """Stream class for {{ cookiecutter.source_name }} streams."""

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

    def prepare_stream(self) -> None:
        """Set up the stream before running.

        This method is called before any message are output. It can be used
        to configure the stream, open connections, etc.
        """
        pass  # TODO: Delete this method if not needed.

    def get_records(self, context: Optional[dict]) -> Iterable[dict]:
        """Return a generator of row-type dictionary objects.

        The optional `context` argument is used to identify a specific slice of the
        stream if partitioning is required for the stream. Most implementations do not
        require partitioning and should ignore the `context` argument.
        """
        # TODO: Write logic to extract data from the upstream source.
        # rows = mysource.getall()
        # for row in rows:
        #     yield row.to_dict()
        raise NotImplementedError("The method is not yet implemented (TODO)")

    def cleanup_stream(self, error: Optional[Exception] = None) -> None:
        """Clean up resources after running.

        This method is called at the end of the stream, including
        after exceptions are thrown. It can be used to clean up resources
        opened during `prepare_stream` such as connections.

        Args:
            error: The error that interrupted the stream, if any.
                Will be `None` if the stream completed successfully.
        """
        pass  # TODO: Delete this method if not needed.